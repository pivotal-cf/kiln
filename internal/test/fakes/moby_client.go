// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"context"
	"io"
	"net"
	"sync"

	"github.com/docker/docker/api/types"
	"github.com/docker/docker/api/types/container"
	"github.com/docker/docker/api/types/network"
	v1 "github.com/opencontainers/image-spec/specs-go/v1"
)

type MobyClient struct {
	ContainerCreateStub        func(context.Context, *container.Config, *container.HostConfig, *network.NetworkingConfig, *v1.Platform, string) (container.CreateResponse, error)
	containerCreateMutex       sync.RWMutex
	containerCreateArgsForCall []struct {
		arg1 context.Context
		arg2 *container.Config
		arg3 *container.HostConfig
		arg4 *network.NetworkingConfig
		arg5 *v1.Platform
		arg6 string
	}
	containerCreateReturns struct {
		result1 container.CreateResponse
		result2 error
	}
	containerCreateReturnsOnCall map[int]struct {
		result1 container.CreateResponse
		result2 error
	}
	ContainerLogsStub        func(context.Context, string, types.ContainerLogsOptions) (io.ReadCloser, error)
	containerLogsMutex       sync.RWMutex
	containerLogsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 types.ContainerLogsOptions
	}
	containerLogsReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	containerLogsReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	ContainerStartStub        func(context.Context, string, types.ContainerStartOptions) error
	containerStartMutex       sync.RWMutex
	containerStartArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 types.ContainerStartOptions
	}
	containerStartReturns struct {
		result1 error
	}
	containerStartReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerStopStub        func(context.Context, string, container.StopOptions) error
	containerStopMutex       sync.RWMutex
	containerStopArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 container.StopOptions
	}
	containerStopReturns struct {
		result1 error
	}
	containerStopReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerWaitStub        func(context.Context, string, container.WaitCondition) (<-chan container.WaitResponse, <-chan error)
	containerWaitMutex       sync.RWMutex
	containerWaitArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 container.WaitCondition
	}
	containerWaitReturns struct {
		result1 <-chan container.WaitResponse
		result2 <-chan error
	}
	containerWaitReturnsOnCall map[int]struct {
		result1 <-chan container.WaitResponse
		result2 <-chan error
	}
	DialHijackStub        func(context.Context, string, string, map[string][]string) (net.Conn, error)
	dialHijackMutex       sync.RWMutex
	dialHijackArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 map[string][]string
	}
	dialHijackReturns struct {
		result1 net.Conn
		result2 error
	}
	dialHijackReturnsOnCall map[int]struct {
		result1 net.Conn
		result2 error
	}
	ImageBuildStub        func(context.Context, io.Reader, types.ImageBuildOptions) (types.ImageBuildResponse, error)
	imageBuildMutex       sync.RWMutex
	imageBuildArgsForCall []struct {
		arg1 context.Context
		arg2 io.Reader
		arg3 types.ImageBuildOptions
	}
	imageBuildReturns struct {
		result1 types.ImageBuildResponse
		result2 error
	}
	imageBuildReturnsOnCall map[int]struct {
		result1 types.ImageBuildResponse
		result2 error
	}
	ImageImportStub        func(context.Context, types.ImageImportSource, string, types.ImageImportOptions) (io.ReadCloser, error)
	imageImportMutex       sync.RWMutex
	imageImportArgsForCall []struct {
		arg1 context.Context
		arg2 types.ImageImportSource
		arg3 string
		arg4 types.ImageImportOptions
	}
	imageImportReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	imageImportReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	ImageLoadStub        func(context.Context, io.Reader, bool) (types.ImageLoadResponse, error)
	imageLoadMutex       sync.RWMutex
	imageLoadArgsForCall []struct {
		arg1 context.Context
		arg2 io.Reader
		arg3 bool
	}
	imageLoadReturns struct {
		result1 types.ImageLoadResponse
		result2 error
	}
	imageLoadReturnsOnCall map[int]struct {
		result1 types.ImageLoadResponse
		result2 error
	}
	PingStub        func(context.Context) (types.Ping, error)
	pingMutex       sync.RWMutex
	pingArgsForCall []struct {
		arg1 context.Context
	}
	pingReturns struct {
		result1 types.Ping
		result2 error
	}
	pingReturnsOnCall map[int]struct {
		result1 types.Ping
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *MobyClient) ContainerCreate(arg1 context.Context, arg2 *container.Config, arg3 *container.HostConfig, arg4 *network.NetworkingConfig, arg5 *v1.Platform, arg6 string) (container.CreateResponse, error) {
	fake.containerCreateMutex.Lock()
	ret, specificReturn := fake.containerCreateReturnsOnCall[len(fake.containerCreateArgsForCall)]
	fake.containerCreateArgsForCall = append(fake.containerCreateArgsForCall, struct {
		arg1 context.Context
		arg2 *container.Config
		arg3 *container.HostConfig
		arg4 *network.NetworkingConfig
		arg5 *v1.Platform
		arg6 string
	}{arg1, arg2, arg3, arg4, arg5, arg6})
	stub := fake.ContainerCreateStub
	fakeReturns := fake.containerCreateReturns
	fake.recordInvocation("ContainerCreate", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.containerCreateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *MobyClient) ContainerCreateCallCount() int {
	fake.containerCreateMutex.RLock()
	defer fake.containerCreateMutex.RUnlock()
	return len(fake.containerCreateArgsForCall)
}

func (fake *MobyClient) ContainerCreateCalls(stub func(context.Context, *container.Config, *container.HostConfig, *network.NetworkingConfig, *v1.Platform, string) (container.CreateResponse, error)) {
	fake.containerCreateMutex.Lock()
	defer fake.containerCreateMutex.Unlock()
	fake.ContainerCreateStub = stub
}

func (fake *MobyClient) ContainerCreateArgsForCall(i int) (context.Context, *container.Config, *container.HostConfig, *network.NetworkingConfig, *v1.Platform, string) {
	fake.containerCreateMutex.RLock()
	defer fake.containerCreateMutex.RUnlock()
	argsForCall := fake.containerCreateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *MobyClient) ContainerCreateReturns(result1 container.CreateResponse, result2 error) {
	fake.containerCreateMutex.Lock()
	defer fake.containerCreateMutex.Unlock()
	fake.ContainerCreateStub = nil
	fake.containerCreateReturns = struct {
		result1 container.CreateResponse
		result2 error
	}{result1, result2}
}

func (fake *MobyClient) ContainerCreateReturnsOnCall(i int, result1 container.CreateResponse, result2 error) {
	fake.containerCreateMutex.Lock()
	defer fake.containerCreateMutex.Unlock()
	fake.ContainerCreateStub = nil
	if fake.containerCreateReturnsOnCall == nil {
		fake.containerCreateReturnsOnCall = make(map[int]struct {
			result1 container.CreateResponse
			result2 error
		})
	}
	fake.containerCreateReturnsOnCall[i] = struct {
		result1 container.CreateResponse
		result2 error
	}{result1, result2}
}

func (fake *MobyClient) ContainerLogs(arg1 context.Context, arg2 string, arg3 types.ContainerLogsOptions) (io.ReadCloser, error) {
	fake.containerLogsMutex.Lock()
	ret, specificReturn := fake.containerLogsReturnsOnCall[len(fake.containerLogsArgsForCall)]
	fake.containerLogsArgsForCall = append(fake.containerLogsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 types.ContainerLogsOptions
	}{arg1, arg2, arg3})
	stub := fake.ContainerLogsStub
	fakeReturns := fake.containerLogsReturns
	fake.recordInvocation("ContainerLogs", []interface{}{arg1, arg2, arg3})
	fake.containerLogsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *MobyClient) ContainerLogsCallCount() int {
	fake.containerLogsMutex.RLock()
	defer fake.containerLogsMutex.RUnlock()
	return len(fake.containerLogsArgsForCall)
}

func (fake *MobyClient) ContainerLogsCalls(stub func(context.Context, string, types.ContainerLogsOptions) (io.ReadCloser, error)) {
	fake.containerLogsMutex.Lock()
	defer fake.containerLogsMutex.Unlock()
	fake.ContainerLogsStub = stub
}

func (fake *MobyClient) ContainerLogsArgsForCall(i int) (context.Context, string, types.ContainerLogsOptions) {
	fake.containerLogsMutex.RLock()
	defer fake.containerLogsMutex.RUnlock()
	argsForCall := fake.containerLogsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *MobyClient) ContainerLogsReturns(result1 io.ReadCloser, result2 error) {
	fake.containerLogsMutex.Lock()
	defer fake.containerLogsMutex.Unlock()
	fake.ContainerLogsStub = nil
	fake.containerLogsReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *MobyClient) ContainerLogsReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.containerLogsMutex.Lock()
	defer fake.containerLogsMutex.Unlock()
	fake.ContainerLogsStub = nil
	if fake.containerLogsReturnsOnCall == nil {
		fake.containerLogsReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.containerLogsReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *MobyClient) ContainerStart(arg1 context.Context, arg2 string, arg3 types.ContainerStartOptions) error {
	fake.containerStartMutex.Lock()
	ret, specificReturn := fake.containerStartReturnsOnCall[len(fake.containerStartArgsForCall)]
	fake.containerStartArgsForCall = append(fake.containerStartArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 types.ContainerStartOptions
	}{arg1, arg2, arg3})
	stub := fake.ContainerStartStub
	fakeReturns := fake.containerStartReturns
	fake.recordInvocation("ContainerStart", []interface{}{arg1, arg2, arg3})
	fake.containerStartMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *MobyClient) ContainerStartCallCount() int {
	fake.containerStartMutex.RLock()
	defer fake.containerStartMutex.RUnlock()
	return len(fake.containerStartArgsForCall)
}

func (fake *MobyClient) ContainerStartCalls(stub func(context.Context, string, types.ContainerStartOptions) error) {
	fake.containerStartMutex.Lock()
	defer fake.containerStartMutex.Unlock()
	fake.ContainerStartStub = stub
}

func (fake *MobyClient) ContainerStartArgsForCall(i int) (context.Context, string, types.ContainerStartOptions) {
	fake.containerStartMutex.RLock()
	defer fake.containerStartMutex.RUnlock()
	argsForCall := fake.containerStartArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *MobyClient) ContainerStartReturns(result1 error) {
	fake.containerStartMutex.Lock()
	defer fake.containerStartMutex.Unlock()
	fake.ContainerStartStub = nil
	fake.containerStartReturns = struct {
		result1 error
	}{result1}
}

func (fake *MobyClient) ContainerStartReturnsOnCall(i int, result1 error) {
	fake.containerStartMutex.Lock()
	defer fake.containerStartMutex.Unlock()
	fake.ContainerStartStub = nil
	if fake.containerStartReturnsOnCall == nil {
		fake.containerStartReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.containerStartReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *MobyClient) ContainerStop(arg1 context.Context, arg2 string, arg3 container.StopOptions) error {
	fake.containerStopMutex.Lock()
	ret, specificReturn := fake.containerStopReturnsOnCall[len(fake.containerStopArgsForCall)]
	fake.containerStopArgsForCall = append(fake.containerStopArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 container.StopOptions
	}{arg1, arg2, arg3})
	stub := fake.ContainerStopStub
	fakeReturns := fake.containerStopReturns
	fake.recordInvocation("ContainerStop", []interface{}{arg1, arg2, arg3})
	fake.containerStopMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *MobyClient) ContainerStopCallCount() int {
	fake.containerStopMutex.RLock()
	defer fake.containerStopMutex.RUnlock()
	return len(fake.containerStopArgsForCall)
}

func (fake *MobyClient) ContainerStopCalls(stub func(context.Context, string, container.StopOptions) error) {
	fake.containerStopMutex.Lock()
	defer fake.containerStopMutex.Unlock()
	fake.ContainerStopStub = stub
}

func (fake *MobyClient) ContainerStopArgsForCall(i int) (context.Context, string, container.StopOptions) {
	fake.containerStopMutex.RLock()
	defer fake.containerStopMutex.RUnlock()
	argsForCall := fake.containerStopArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *MobyClient) ContainerStopReturns(result1 error) {
	fake.containerStopMutex.Lock()
	defer fake.containerStopMutex.Unlock()
	fake.ContainerStopStub = nil
	fake.containerStopReturns = struct {
		result1 error
	}{result1}
}

func (fake *MobyClient) ContainerStopReturnsOnCall(i int, result1 error) {
	fake.containerStopMutex.Lock()
	defer fake.containerStopMutex.Unlock()
	fake.ContainerStopStub = nil
	if fake.containerStopReturnsOnCall == nil {
		fake.containerStopReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.containerStopReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *MobyClient) ContainerWait(arg1 context.Context, arg2 string, arg3 container.WaitCondition) (<-chan container.WaitResponse, <-chan error) {
	fake.containerWaitMutex.Lock()
	ret, specificReturn := fake.containerWaitReturnsOnCall[len(fake.containerWaitArgsForCall)]
	fake.containerWaitArgsForCall = append(fake.containerWaitArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 container.WaitCondition
	}{arg1, arg2, arg3})
	stub := fake.ContainerWaitStub
	fakeReturns := fake.containerWaitReturns
	fake.recordInvocation("ContainerWait", []interface{}{arg1, arg2, arg3})
	fake.containerWaitMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *MobyClient) ContainerWaitCallCount() int {
	fake.containerWaitMutex.RLock()
	defer fake.containerWaitMutex.RUnlock()
	return len(fake.containerWaitArgsForCall)
}

func (fake *MobyClient) ContainerWaitCalls(stub func(context.Context, string, container.WaitCondition) (<-chan container.WaitResponse, <-chan error)) {
	fake.containerWaitMutex.Lock()
	defer fake.containerWaitMutex.Unlock()
	fake.ContainerWaitStub = stub
}

func (fake *MobyClient) ContainerWaitArgsForCall(i int) (context.Context, string, container.WaitCondition) {
	fake.containerWaitMutex.RLock()
	defer fake.containerWaitMutex.RUnlock()
	argsForCall := fake.containerWaitArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *MobyClient) ContainerWaitReturns(result1 <-chan container.WaitResponse, result2 <-chan error) {
	fake.containerWaitMutex.Lock()
	defer fake.containerWaitMutex.Unlock()
	fake.ContainerWaitStub = nil
	fake.containerWaitReturns = struct {
		result1 <-chan container.WaitResponse
		result2 <-chan error
	}{result1, result2}
}

func (fake *MobyClient) ContainerWaitReturnsOnCall(i int, result1 <-chan container.WaitResponse, result2 <-chan error) {
	fake.containerWaitMutex.Lock()
	defer fake.containerWaitMutex.Unlock()
	fake.ContainerWaitStub = nil
	if fake.containerWaitReturnsOnCall == nil {
		fake.containerWaitReturnsOnCall = make(map[int]struct {
			result1 <-chan container.WaitResponse
			result2 <-chan error
		})
	}
	fake.containerWaitReturnsOnCall[i] = struct {
		result1 <-chan container.WaitResponse
		result2 <-chan error
	}{result1, result2}
}

func (fake *MobyClient) DialHijack(arg1 context.Context, arg2 string, arg3 string, arg4 map[string][]string) (net.Conn, error) {
	fake.dialHijackMutex.Lock()
	ret, specificReturn := fake.dialHijackReturnsOnCall[len(fake.dialHijackArgsForCall)]
	fake.dialHijackArgsForCall = append(fake.dialHijackArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 map[string][]string
	}{arg1, arg2, arg3, arg4})
	stub := fake.DialHijackStub
	fakeReturns := fake.dialHijackReturns
	fake.recordInvocation("DialHijack", []interface{}{arg1, arg2, arg3, arg4})
	fake.dialHijackMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *MobyClient) DialHijackCallCount() int {
	fake.dialHijackMutex.RLock()
	defer fake.dialHijackMutex.RUnlock()
	return len(fake.dialHijackArgsForCall)
}

func (fake *MobyClient) DialHijackCalls(stub func(context.Context, string, string, map[string][]string) (net.Conn, error)) {
	fake.dialHijackMutex.Lock()
	defer fake.dialHijackMutex.Unlock()
	fake.DialHijackStub = stub
}

func (fake *MobyClient) DialHijackArgsForCall(i int) (context.Context, string, string, map[string][]string) {
	fake.dialHijackMutex.RLock()
	defer fake.dialHijackMutex.RUnlock()
	argsForCall := fake.dialHijackArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *MobyClient) DialHijackReturns(result1 net.Conn, result2 error) {
	fake.dialHijackMutex.Lock()
	defer fake.dialHijackMutex.Unlock()
	fake.DialHijackStub = nil
	fake.dialHijackReturns = struct {
		result1 net.Conn
		result2 error
	}{result1, result2}
}

func (fake *MobyClient) DialHijackReturnsOnCall(i int, result1 net.Conn, result2 error) {
	fake.dialHijackMutex.Lock()
	defer fake.dialHijackMutex.Unlock()
	fake.DialHijackStub = nil
	if fake.dialHijackReturnsOnCall == nil {
		fake.dialHijackReturnsOnCall = make(map[int]struct {
			result1 net.Conn
			result2 error
		})
	}
	fake.dialHijackReturnsOnCall[i] = struct {
		result1 net.Conn
		result2 error
	}{result1, result2}
}

func (fake *MobyClient) ImageBuild(arg1 context.Context, arg2 io.Reader, arg3 types.ImageBuildOptions) (types.ImageBuildResponse, error) {
	fake.imageBuildMutex.Lock()
	ret, specificReturn := fake.imageBuildReturnsOnCall[len(fake.imageBuildArgsForCall)]
	fake.imageBuildArgsForCall = append(fake.imageBuildArgsForCall, struct {
		arg1 context.Context
		arg2 io.Reader
		arg3 types.ImageBuildOptions
	}{arg1, arg2, arg3})
	stub := fake.ImageBuildStub
	fakeReturns := fake.imageBuildReturns
	fake.recordInvocation("ImageBuild", []interface{}{arg1, arg2, arg3})
	fake.imageBuildMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *MobyClient) ImageBuildCallCount() int {
	fake.imageBuildMutex.RLock()
	defer fake.imageBuildMutex.RUnlock()
	return len(fake.imageBuildArgsForCall)
}

func (fake *MobyClient) ImageBuildCalls(stub func(context.Context, io.Reader, types.ImageBuildOptions) (types.ImageBuildResponse, error)) {
	fake.imageBuildMutex.Lock()
	defer fake.imageBuildMutex.Unlock()
	fake.ImageBuildStub = stub
}

func (fake *MobyClient) ImageBuildArgsForCall(i int) (context.Context, io.Reader, types.ImageBuildOptions) {
	fake.imageBuildMutex.RLock()
	defer fake.imageBuildMutex.RUnlock()
	argsForCall := fake.imageBuildArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *MobyClient) ImageBuildReturns(result1 types.ImageBuildResponse, result2 error) {
	fake.imageBuildMutex.Lock()
	defer fake.imageBuildMutex.Unlock()
	fake.ImageBuildStub = nil
	fake.imageBuildReturns = struct {
		result1 types.ImageBuildResponse
		result2 error
	}{result1, result2}
}

func (fake *MobyClient) ImageBuildReturnsOnCall(i int, result1 types.ImageBuildResponse, result2 error) {
	fake.imageBuildMutex.Lock()
	defer fake.imageBuildMutex.Unlock()
	fake.ImageBuildStub = nil
	if fake.imageBuildReturnsOnCall == nil {
		fake.imageBuildReturnsOnCall = make(map[int]struct {
			result1 types.ImageBuildResponse
			result2 error
		})
	}
	fake.imageBuildReturnsOnCall[i] = struct {
		result1 types.ImageBuildResponse
		result2 error
	}{result1, result2}
}

func (fake *MobyClient) ImageImport(arg1 context.Context, arg2 types.ImageImportSource, arg3 string, arg4 types.ImageImportOptions) (io.ReadCloser, error) {
	fake.imageImportMutex.Lock()
	ret, specificReturn := fake.imageImportReturnsOnCall[len(fake.imageImportArgsForCall)]
	fake.imageImportArgsForCall = append(fake.imageImportArgsForCall, struct {
		arg1 context.Context
		arg2 types.ImageImportSource
		arg3 string
		arg4 types.ImageImportOptions
	}{arg1, arg2, arg3, arg4})
	stub := fake.ImageImportStub
	fakeReturns := fake.imageImportReturns
	fake.recordInvocation("ImageImport", []interface{}{arg1, arg2, arg3, arg4})
	fake.imageImportMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *MobyClient) ImageImportCallCount() int {
	fake.imageImportMutex.RLock()
	defer fake.imageImportMutex.RUnlock()
	return len(fake.imageImportArgsForCall)
}

func (fake *MobyClient) ImageImportCalls(stub func(context.Context, types.ImageImportSource, string, types.ImageImportOptions) (io.ReadCloser, error)) {
	fake.imageImportMutex.Lock()
	defer fake.imageImportMutex.Unlock()
	fake.ImageImportStub = stub
}

func (fake *MobyClient) ImageImportArgsForCall(i int) (context.Context, types.ImageImportSource, string, types.ImageImportOptions) {
	fake.imageImportMutex.RLock()
	defer fake.imageImportMutex.RUnlock()
	argsForCall := fake.imageImportArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *MobyClient) ImageImportReturns(result1 io.ReadCloser, result2 error) {
	fake.imageImportMutex.Lock()
	defer fake.imageImportMutex.Unlock()
	fake.ImageImportStub = nil
	fake.imageImportReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *MobyClient) ImageImportReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.imageImportMutex.Lock()
	defer fake.imageImportMutex.Unlock()
	fake.ImageImportStub = nil
	if fake.imageImportReturnsOnCall == nil {
		fake.imageImportReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.imageImportReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *MobyClient) ImageLoad(arg1 context.Context, arg2 io.Reader, arg3 bool) (types.ImageLoadResponse, error) {
	fake.imageLoadMutex.Lock()
	ret, specificReturn := fake.imageLoadReturnsOnCall[len(fake.imageLoadArgsForCall)]
	fake.imageLoadArgsForCall = append(fake.imageLoadArgsForCall, struct {
		arg1 context.Context
		arg2 io.Reader
		arg3 bool
	}{arg1, arg2, arg3})
	stub := fake.ImageLoadStub
	fakeReturns := fake.imageLoadReturns
	fake.recordInvocation("ImageLoad", []interface{}{arg1, arg2, arg3})
	fake.imageLoadMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *MobyClient) ImageLoadCallCount() int {
	fake.imageLoadMutex.RLock()
	defer fake.imageLoadMutex.RUnlock()
	return len(fake.imageLoadArgsForCall)
}

func (fake *MobyClient) ImageLoadCalls(stub func(context.Context, io.Reader, bool) (types.ImageLoadResponse, error)) {
	fake.imageLoadMutex.Lock()
	defer fake.imageLoadMutex.Unlock()
	fake.ImageLoadStub = stub
}

func (fake *MobyClient) ImageLoadArgsForCall(i int) (context.Context, io.Reader, bool) {
	fake.imageLoadMutex.RLock()
	defer fake.imageLoadMutex.RUnlock()
	argsForCall := fake.imageLoadArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *MobyClient) ImageLoadReturns(result1 types.ImageLoadResponse, result2 error) {
	fake.imageLoadMutex.Lock()
	defer fake.imageLoadMutex.Unlock()
	fake.ImageLoadStub = nil
	fake.imageLoadReturns = struct {
		result1 types.ImageLoadResponse
		result2 error
	}{result1, result2}
}

func (fake *MobyClient) ImageLoadReturnsOnCall(i int, result1 types.ImageLoadResponse, result2 error) {
	fake.imageLoadMutex.Lock()
	defer fake.imageLoadMutex.Unlock()
	fake.ImageLoadStub = nil
	if fake.imageLoadReturnsOnCall == nil {
		fake.imageLoadReturnsOnCall = make(map[int]struct {
			result1 types.ImageLoadResponse
			result2 error
		})
	}
	fake.imageLoadReturnsOnCall[i] = struct {
		result1 types.ImageLoadResponse
		result2 error
	}{result1, result2}
}

func (fake *MobyClient) Ping(arg1 context.Context) (types.Ping, error) {
	fake.pingMutex.Lock()
	ret, specificReturn := fake.pingReturnsOnCall[len(fake.pingArgsForCall)]
	fake.pingArgsForCall = append(fake.pingArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.PingStub
	fakeReturns := fake.pingReturns
	fake.recordInvocation("Ping", []interface{}{arg1})
	fake.pingMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *MobyClient) PingCallCount() int {
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	return len(fake.pingArgsForCall)
}

func (fake *MobyClient) PingCalls(stub func(context.Context) (types.Ping, error)) {
	fake.pingMutex.Lock()
	defer fake.pingMutex.Unlock()
	fake.PingStub = stub
}

func (fake *MobyClient) PingArgsForCall(i int) context.Context {
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	argsForCall := fake.pingArgsForCall[i]
	return argsForCall.arg1
}

func (fake *MobyClient) PingReturns(result1 types.Ping, result2 error) {
	fake.pingMutex.Lock()
	defer fake.pingMutex.Unlock()
	fake.PingStub = nil
	fake.pingReturns = struct {
		result1 types.Ping
		result2 error
	}{result1, result2}
}

func (fake *MobyClient) PingReturnsOnCall(i int, result1 types.Ping, result2 error) {
	fake.pingMutex.Lock()
	defer fake.pingMutex.Unlock()
	fake.PingStub = nil
	if fake.pingReturnsOnCall == nil {
		fake.pingReturnsOnCall = make(map[int]struct {
			result1 types.Ping
			result2 error
		})
	}
	fake.pingReturnsOnCall[i] = struct {
		result1 types.Ping
		result2 error
	}{result1, result2}
}

func (fake *MobyClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.containerCreateMutex.RLock()
	defer fake.containerCreateMutex.RUnlock()
	fake.containerLogsMutex.RLock()
	defer fake.containerLogsMutex.RUnlock()
	fake.containerStartMutex.RLock()
	defer fake.containerStartMutex.RUnlock()
	fake.containerStopMutex.RLock()
	defer fake.containerStopMutex.RUnlock()
	fake.containerWaitMutex.RLock()
	defer fake.containerWaitMutex.RUnlock()
	fake.dialHijackMutex.RLock()
	defer fake.dialHijackMutex.RUnlock()
	fake.imageBuildMutex.RLock()
	defer fake.imageBuildMutex.RUnlock()
	fake.imageImportMutex.RLock()
	defer fake.imageImportMutex.RUnlock()
	fake.imageLoadMutex.RLock()
	defer fake.imageLoadMutex.RUnlock()
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *MobyClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
