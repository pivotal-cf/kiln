// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"io"
	"sync"

	"github.com/cloudfoundry/bosh-cli/director"
	"github.com/pivotal-cf/kiln/internal/commands"
)

type BoshDirector struct {
	CleanUpStub        func(bool, bool, bool) (director.CleanUp, error)
	cleanUpMutex       sync.RWMutex
	cleanUpArgsForCall []struct {
		arg1 bool
		arg2 bool
		arg3 bool
	}
	cleanUpReturns struct {
		result1 director.CleanUp
		result2 error
	}
	cleanUpReturnsOnCall map[int]struct {
		result1 director.CleanUp
		result2 error
	}
	DownloadResourceUncheckedStub        func(string, io.Writer) error
	downloadResourceUncheckedMutex       sync.RWMutex
	downloadResourceUncheckedArgsForCall []struct {
		arg1 string
		arg2 io.Writer
	}
	downloadResourceUncheckedReturns struct {
		result1 error
	}
	downloadResourceUncheckedReturnsOnCall map[int]struct {
		result1 error
	}
	FindDeploymentStub        func(string) (director.Deployment, error)
	findDeploymentMutex       sync.RWMutex
	findDeploymentArgsForCall []struct {
		arg1 string
	}
	findDeploymentReturns struct {
		result1 director.Deployment
		result2 error
	}
	findDeploymentReturnsOnCall map[int]struct {
		result1 director.Deployment
		result2 error
	}
	UploadReleaseFileStub        func(director.UploadFile, bool, bool) error
	uploadReleaseFileMutex       sync.RWMutex
	uploadReleaseFileArgsForCall []struct {
		arg1 director.UploadFile
		arg2 bool
		arg3 bool
	}
	uploadReleaseFileReturns struct {
		result1 error
	}
	uploadReleaseFileReturnsOnCall map[int]struct {
		result1 error
	}
	UploadStemcellFileStub        func(director.UploadFile, bool) error
	uploadStemcellFileMutex       sync.RWMutex
	uploadStemcellFileArgsForCall []struct {
		arg1 director.UploadFile
		arg2 bool
	}
	uploadStemcellFileReturns struct {
		result1 error
	}
	uploadStemcellFileReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *BoshDirector) CleanUp(arg1 bool, arg2 bool, arg3 bool) (director.CleanUp, error) {
	fake.cleanUpMutex.Lock()
	ret, specificReturn := fake.cleanUpReturnsOnCall[len(fake.cleanUpArgsForCall)]
	fake.cleanUpArgsForCall = append(fake.cleanUpArgsForCall, struct {
		arg1 bool
		arg2 bool
		arg3 bool
	}{arg1, arg2, arg3})
	stub := fake.CleanUpStub
	fakeReturns := fake.cleanUpReturns
	fake.recordInvocation("CleanUp", []interface{}{arg1, arg2, arg3})
	fake.cleanUpMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *BoshDirector) CleanUpCallCount() int {
	fake.cleanUpMutex.RLock()
	defer fake.cleanUpMutex.RUnlock()
	return len(fake.cleanUpArgsForCall)
}

func (fake *BoshDirector) CleanUpCalls(stub func(bool, bool, bool) (director.CleanUp, error)) {
	fake.cleanUpMutex.Lock()
	defer fake.cleanUpMutex.Unlock()
	fake.CleanUpStub = stub
}

func (fake *BoshDirector) CleanUpArgsForCall(i int) (bool, bool, bool) {
	fake.cleanUpMutex.RLock()
	defer fake.cleanUpMutex.RUnlock()
	argsForCall := fake.cleanUpArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *BoshDirector) CleanUpReturns(result1 director.CleanUp, result2 error) {
	fake.cleanUpMutex.Lock()
	defer fake.cleanUpMutex.Unlock()
	fake.CleanUpStub = nil
	fake.cleanUpReturns = struct {
		result1 director.CleanUp
		result2 error
	}{result1, result2}
}

func (fake *BoshDirector) CleanUpReturnsOnCall(i int, result1 director.CleanUp, result2 error) {
	fake.cleanUpMutex.Lock()
	defer fake.cleanUpMutex.Unlock()
	fake.CleanUpStub = nil
	if fake.cleanUpReturnsOnCall == nil {
		fake.cleanUpReturnsOnCall = make(map[int]struct {
			result1 director.CleanUp
			result2 error
		})
	}
	fake.cleanUpReturnsOnCall[i] = struct {
		result1 director.CleanUp
		result2 error
	}{result1, result2}
}

func (fake *BoshDirector) DownloadResourceUnchecked(arg1 string, arg2 io.Writer) error {
	fake.downloadResourceUncheckedMutex.Lock()
	ret, specificReturn := fake.downloadResourceUncheckedReturnsOnCall[len(fake.downloadResourceUncheckedArgsForCall)]
	fake.downloadResourceUncheckedArgsForCall = append(fake.downloadResourceUncheckedArgsForCall, struct {
		arg1 string
		arg2 io.Writer
	}{arg1, arg2})
	stub := fake.DownloadResourceUncheckedStub
	fakeReturns := fake.downloadResourceUncheckedReturns
	fake.recordInvocation("DownloadResourceUnchecked", []interface{}{arg1, arg2})
	fake.downloadResourceUncheckedMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *BoshDirector) DownloadResourceUncheckedCallCount() int {
	fake.downloadResourceUncheckedMutex.RLock()
	defer fake.downloadResourceUncheckedMutex.RUnlock()
	return len(fake.downloadResourceUncheckedArgsForCall)
}

func (fake *BoshDirector) DownloadResourceUncheckedCalls(stub func(string, io.Writer) error) {
	fake.downloadResourceUncheckedMutex.Lock()
	defer fake.downloadResourceUncheckedMutex.Unlock()
	fake.DownloadResourceUncheckedStub = stub
}

func (fake *BoshDirector) DownloadResourceUncheckedArgsForCall(i int) (string, io.Writer) {
	fake.downloadResourceUncheckedMutex.RLock()
	defer fake.downloadResourceUncheckedMutex.RUnlock()
	argsForCall := fake.downloadResourceUncheckedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *BoshDirector) DownloadResourceUncheckedReturns(result1 error) {
	fake.downloadResourceUncheckedMutex.Lock()
	defer fake.downloadResourceUncheckedMutex.Unlock()
	fake.DownloadResourceUncheckedStub = nil
	fake.downloadResourceUncheckedReturns = struct {
		result1 error
	}{result1}
}

func (fake *BoshDirector) DownloadResourceUncheckedReturnsOnCall(i int, result1 error) {
	fake.downloadResourceUncheckedMutex.Lock()
	defer fake.downloadResourceUncheckedMutex.Unlock()
	fake.DownloadResourceUncheckedStub = nil
	if fake.downloadResourceUncheckedReturnsOnCall == nil {
		fake.downloadResourceUncheckedReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.downloadResourceUncheckedReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *BoshDirector) FindDeployment(arg1 string) (director.Deployment, error) {
	fake.findDeploymentMutex.Lock()
	ret, specificReturn := fake.findDeploymentReturnsOnCall[len(fake.findDeploymentArgsForCall)]
	fake.findDeploymentArgsForCall = append(fake.findDeploymentArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.FindDeploymentStub
	fakeReturns := fake.findDeploymentReturns
	fake.recordInvocation("FindDeployment", []interface{}{arg1})
	fake.findDeploymentMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *BoshDirector) FindDeploymentCallCount() int {
	fake.findDeploymentMutex.RLock()
	defer fake.findDeploymentMutex.RUnlock()
	return len(fake.findDeploymentArgsForCall)
}

func (fake *BoshDirector) FindDeploymentCalls(stub func(string) (director.Deployment, error)) {
	fake.findDeploymentMutex.Lock()
	defer fake.findDeploymentMutex.Unlock()
	fake.FindDeploymentStub = stub
}

func (fake *BoshDirector) FindDeploymentArgsForCall(i int) string {
	fake.findDeploymentMutex.RLock()
	defer fake.findDeploymentMutex.RUnlock()
	argsForCall := fake.findDeploymentArgsForCall[i]
	return argsForCall.arg1
}

func (fake *BoshDirector) FindDeploymentReturns(result1 director.Deployment, result2 error) {
	fake.findDeploymentMutex.Lock()
	defer fake.findDeploymentMutex.Unlock()
	fake.FindDeploymentStub = nil
	fake.findDeploymentReturns = struct {
		result1 director.Deployment
		result2 error
	}{result1, result2}
}

func (fake *BoshDirector) FindDeploymentReturnsOnCall(i int, result1 director.Deployment, result2 error) {
	fake.findDeploymentMutex.Lock()
	defer fake.findDeploymentMutex.Unlock()
	fake.FindDeploymentStub = nil
	if fake.findDeploymentReturnsOnCall == nil {
		fake.findDeploymentReturnsOnCall = make(map[int]struct {
			result1 director.Deployment
			result2 error
		})
	}
	fake.findDeploymentReturnsOnCall[i] = struct {
		result1 director.Deployment
		result2 error
	}{result1, result2}
}

func (fake *BoshDirector) UploadReleaseFile(arg1 director.UploadFile, arg2 bool, arg3 bool) error {
	fake.uploadReleaseFileMutex.Lock()
	ret, specificReturn := fake.uploadReleaseFileReturnsOnCall[len(fake.uploadReleaseFileArgsForCall)]
	fake.uploadReleaseFileArgsForCall = append(fake.uploadReleaseFileArgsForCall, struct {
		arg1 director.UploadFile
		arg2 bool
		arg3 bool
	}{arg1, arg2, arg3})
	stub := fake.UploadReleaseFileStub
	fakeReturns := fake.uploadReleaseFileReturns
	fake.recordInvocation("UploadReleaseFile", []interface{}{arg1, arg2, arg3})
	fake.uploadReleaseFileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *BoshDirector) UploadReleaseFileCallCount() int {
	fake.uploadReleaseFileMutex.RLock()
	defer fake.uploadReleaseFileMutex.RUnlock()
	return len(fake.uploadReleaseFileArgsForCall)
}

func (fake *BoshDirector) UploadReleaseFileCalls(stub func(director.UploadFile, bool, bool) error) {
	fake.uploadReleaseFileMutex.Lock()
	defer fake.uploadReleaseFileMutex.Unlock()
	fake.UploadReleaseFileStub = stub
}

func (fake *BoshDirector) UploadReleaseFileArgsForCall(i int) (director.UploadFile, bool, bool) {
	fake.uploadReleaseFileMutex.RLock()
	defer fake.uploadReleaseFileMutex.RUnlock()
	argsForCall := fake.uploadReleaseFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *BoshDirector) UploadReleaseFileReturns(result1 error) {
	fake.uploadReleaseFileMutex.Lock()
	defer fake.uploadReleaseFileMutex.Unlock()
	fake.UploadReleaseFileStub = nil
	fake.uploadReleaseFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *BoshDirector) UploadReleaseFileReturnsOnCall(i int, result1 error) {
	fake.uploadReleaseFileMutex.Lock()
	defer fake.uploadReleaseFileMutex.Unlock()
	fake.UploadReleaseFileStub = nil
	if fake.uploadReleaseFileReturnsOnCall == nil {
		fake.uploadReleaseFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.uploadReleaseFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *BoshDirector) UploadStemcellFile(arg1 director.UploadFile, arg2 bool) error {
	fake.uploadStemcellFileMutex.Lock()
	ret, specificReturn := fake.uploadStemcellFileReturnsOnCall[len(fake.uploadStemcellFileArgsForCall)]
	fake.uploadStemcellFileArgsForCall = append(fake.uploadStemcellFileArgsForCall, struct {
		arg1 director.UploadFile
		arg2 bool
	}{arg1, arg2})
	stub := fake.UploadStemcellFileStub
	fakeReturns := fake.uploadStemcellFileReturns
	fake.recordInvocation("UploadStemcellFile", []interface{}{arg1, arg2})
	fake.uploadStemcellFileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *BoshDirector) UploadStemcellFileCallCount() int {
	fake.uploadStemcellFileMutex.RLock()
	defer fake.uploadStemcellFileMutex.RUnlock()
	return len(fake.uploadStemcellFileArgsForCall)
}

func (fake *BoshDirector) UploadStemcellFileCalls(stub func(director.UploadFile, bool) error) {
	fake.uploadStemcellFileMutex.Lock()
	defer fake.uploadStemcellFileMutex.Unlock()
	fake.UploadStemcellFileStub = stub
}

func (fake *BoshDirector) UploadStemcellFileArgsForCall(i int) (director.UploadFile, bool) {
	fake.uploadStemcellFileMutex.RLock()
	defer fake.uploadStemcellFileMutex.RUnlock()
	argsForCall := fake.uploadStemcellFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *BoshDirector) UploadStemcellFileReturns(result1 error) {
	fake.uploadStemcellFileMutex.Lock()
	defer fake.uploadStemcellFileMutex.Unlock()
	fake.UploadStemcellFileStub = nil
	fake.uploadStemcellFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *BoshDirector) UploadStemcellFileReturnsOnCall(i int, result1 error) {
	fake.uploadStemcellFileMutex.Lock()
	defer fake.uploadStemcellFileMutex.Unlock()
	fake.UploadStemcellFileStub = nil
	if fake.uploadStemcellFileReturnsOnCall == nil {
		fake.uploadStemcellFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.uploadStemcellFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *BoshDirector) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.cleanUpMutex.RLock()
	defer fake.cleanUpMutex.RUnlock()
	fake.downloadResourceUncheckedMutex.RLock()
	defer fake.downloadResourceUncheckedMutex.RUnlock()
	fake.findDeploymentMutex.RLock()
	defer fake.findDeploymentMutex.RUnlock()
	fake.uploadReleaseFileMutex.RLock()
	defer fake.uploadReleaseFileMutex.RUnlock()
	fake.uploadStemcellFileMutex.RLock()
	defer fake.uploadStemcellFileMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *BoshDirector) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ commands.BoshDirector = new(BoshDirector)
