// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"github.com/pivotal-cf/kiln/internal/commands"
)

type SshProvider struct {
	AddKeyStub        func(commands.Key, []byte) error
	addKeyMutex       sync.RWMutex
	addKeyArgsForCall []struct {
		arg1 commands.Key
		arg2 []byte
	}
	addKeyReturns struct {
		result1 error
	}
	addKeyReturnsOnCall map[int]struct {
		result1 error
	}
	GetKeysStub        func(...string) (commands.Key, error)
	getKeysMutex       sync.RWMutex
	getKeysArgsForCall []struct {
		arg1 []string
	}
	getKeysReturns struct {
		result1 commands.Key
		result2 error
	}
	getKeysReturnsOnCall map[int]struct {
		result1 commands.Key
		result2 error
	}
	NeedsKeysStub        func() (bool, error)
	needsKeysMutex       sync.RWMutex
	needsKeysArgsForCall []struct {
	}
	needsKeysReturns struct {
		result1 bool
		result2 error
	}
	needsKeysReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *SshProvider) AddKey(arg1 commands.Key, arg2 []byte) error {
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.addKeyMutex.Lock()
	ret, specificReturn := fake.addKeyReturnsOnCall[len(fake.addKeyArgsForCall)]
	fake.addKeyArgsForCall = append(fake.addKeyArgsForCall, struct {
		arg1 commands.Key
		arg2 []byte
	}{arg1, arg2Copy})
	stub := fake.AddKeyStub
	fakeReturns := fake.addKeyReturns
	fake.recordInvocation("AddKey", []interface{}{arg1, arg2Copy})
	fake.addKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *SshProvider) AddKeyCallCount() int {
	fake.addKeyMutex.RLock()
	defer fake.addKeyMutex.RUnlock()
	return len(fake.addKeyArgsForCall)
}

func (fake *SshProvider) AddKeyCalls(stub func(commands.Key, []byte) error) {
	fake.addKeyMutex.Lock()
	defer fake.addKeyMutex.Unlock()
	fake.AddKeyStub = stub
}

func (fake *SshProvider) AddKeyArgsForCall(i int) (commands.Key, []byte) {
	fake.addKeyMutex.RLock()
	defer fake.addKeyMutex.RUnlock()
	argsForCall := fake.addKeyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *SshProvider) AddKeyReturns(result1 error) {
	fake.addKeyMutex.Lock()
	defer fake.addKeyMutex.Unlock()
	fake.AddKeyStub = nil
	fake.addKeyReturns = struct {
		result1 error
	}{result1}
}

func (fake *SshProvider) AddKeyReturnsOnCall(i int, result1 error) {
	fake.addKeyMutex.Lock()
	defer fake.addKeyMutex.Unlock()
	fake.AddKeyStub = nil
	if fake.addKeyReturnsOnCall == nil {
		fake.addKeyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addKeyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *SshProvider) GetKeys(arg1 ...string) (commands.Key, error) {
	fake.getKeysMutex.Lock()
	ret, specificReturn := fake.getKeysReturnsOnCall[len(fake.getKeysArgsForCall)]
	fake.getKeysArgsForCall = append(fake.getKeysArgsForCall, struct {
		arg1 []string
	}{arg1})
	stub := fake.GetKeysStub
	fakeReturns := fake.getKeysReturns
	fake.recordInvocation("GetKeys", []interface{}{arg1})
	fake.getKeysMutex.Unlock()
	if stub != nil {
		return stub(arg1...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *SshProvider) GetKeysCallCount() int {
	fake.getKeysMutex.RLock()
	defer fake.getKeysMutex.RUnlock()
	return len(fake.getKeysArgsForCall)
}

func (fake *SshProvider) GetKeysCalls(stub func(...string) (commands.Key, error)) {
	fake.getKeysMutex.Lock()
	defer fake.getKeysMutex.Unlock()
	fake.GetKeysStub = stub
}

func (fake *SshProvider) GetKeysArgsForCall(i int) []string {
	fake.getKeysMutex.RLock()
	defer fake.getKeysMutex.RUnlock()
	argsForCall := fake.getKeysArgsForCall[i]
	return argsForCall.arg1
}

func (fake *SshProvider) GetKeysReturns(result1 commands.Key, result2 error) {
	fake.getKeysMutex.Lock()
	defer fake.getKeysMutex.Unlock()
	fake.GetKeysStub = nil
	fake.getKeysReturns = struct {
		result1 commands.Key
		result2 error
	}{result1, result2}
}

func (fake *SshProvider) GetKeysReturnsOnCall(i int, result1 commands.Key, result2 error) {
	fake.getKeysMutex.Lock()
	defer fake.getKeysMutex.Unlock()
	fake.GetKeysStub = nil
	if fake.getKeysReturnsOnCall == nil {
		fake.getKeysReturnsOnCall = make(map[int]struct {
			result1 commands.Key
			result2 error
		})
	}
	fake.getKeysReturnsOnCall[i] = struct {
		result1 commands.Key
		result2 error
	}{result1, result2}
}

func (fake *SshProvider) NeedsKeys() (bool, error) {
	fake.needsKeysMutex.Lock()
	ret, specificReturn := fake.needsKeysReturnsOnCall[len(fake.needsKeysArgsForCall)]
	fake.needsKeysArgsForCall = append(fake.needsKeysArgsForCall, struct {
	}{})
	stub := fake.NeedsKeysStub
	fakeReturns := fake.needsKeysReturns
	fake.recordInvocation("NeedsKeys", []interface{}{})
	fake.needsKeysMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *SshProvider) NeedsKeysCallCount() int {
	fake.needsKeysMutex.RLock()
	defer fake.needsKeysMutex.RUnlock()
	return len(fake.needsKeysArgsForCall)
}

func (fake *SshProvider) NeedsKeysCalls(stub func() (bool, error)) {
	fake.needsKeysMutex.Lock()
	defer fake.needsKeysMutex.Unlock()
	fake.NeedsKeysStub = stub
}

func (fake *SshProvider) NeedsKeysReturns(result1 bool, result2 error) {
	fake.needsKeysMutex.Lock()
	defer fake.needsKeysMutex.Unlock()
	fake.NeedsKeysStub = nil
	fake.needsKeysReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *SshProvider) NeedsKeysReturnsOnCall(i int, result1 bool, result2 error) {
	fake.needsKeysMutex.Lock()
	defer fake.needsKeysMutex.Unlock()
	fake.NeedsKeysStub = nil
	if fake.needsKeysReturnsOnCall == nil {
		fake.needsKeysReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.needsKeysReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *SshProvider) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addKeyMutex.RLock()
	defer fake.addKeyMutex.RUnlock()
	fake.getKeysMutex.RLock()
	defer fake.getKeysMutex.RUnlock()
	fake.needsKeysMutex.RLock()
	defer fake.needsKeysMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *SshProvider) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ commands.SSHProvider = new(SshProvider)
